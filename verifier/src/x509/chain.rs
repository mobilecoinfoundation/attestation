// Copyright (c) 2023 The MobileCoin Foundation

//! Support for verifying certificate chains

extern crate alloc;

use super::certs::UnverifiedCertificate;
use super::{Error, Result};
use crate::x509::algorithm::PublicKey;
use crate::x509::certs::VerifiedCertificate;
use crate::x509::crl::UnverifiedCrl;
use alloc::vec::Vec;
use core::time::Duration;

/// An X509 certificate chain. This is a valid path from the trust root to the
/// leaf certificate.
#[derive(Debug, PartialEq)]
pub struct CertificateChain {
    certificates: Vec<UnverifiedCertificate>,
}

impl CertificateChain {
    /// Create a new certificate chain from a path from a trust root to the
    /// leaf certificate.
    ///
    /// A certificate chain without a valid path will result in errors for
    /// functions like [`CertificateChain::signing_key`].
    pub fn new(certificates: Vec<UnverifiedCertificate>) -> Self {
        Self { certificates }
    }

    /// Returning the signing key from the leaf certificate
    ///
    /// The chain will be verified against the `trust_anchor`, `unix_time`, and
    /// `crls`.
    ///
    /// # Arguments
    /// * `trust_anchor` - The trust anchor of the chain. This is often a
    ///   previously known certificate.
    /// * `unix_time` - The duration since
    ///   [`UNIX_EPOCH`](https://doc.rust-lang.org/std/time/constant.UNIX_EPOCH.html).
    ///   This is expected to be generated by the caller using:
    ///     ```ignore
    ///     SystemTime::now().duration_since(UNIX_EPOCH)
    ///     ```
    ///   or equivalent
    /// * `crls` - A list of certificate revocation lists that will be used to
    ///   reject revoked certificates.
    pub fn signing_key(
        &self,
        trust_anchor: &VerifiedCertificate,
        unix_time: Duration,
        crls: &[UnverifiedCrl],
    ) -> Result<PublicKey> {
        let mut signing_cert = trust_anchor.clone();
        for cert in &self.certificates {
            let key = signing_cert.public_key();
            let verified_cert = cert.verify(key, unix_time)?;
            verify_certificate_not_revoked(&verified_cert, &signing_cert, crls, unix_time)?;
            signing_cert = verified_cert;
        }
        Ok(signing_cert.public_key().clone())
    }
}

/// Convert a series PEM-encoded certificates into a [`CertificateChain`].
///
/// The PEMs must be in order from the trust anchor to the leaf certificate.
impl TryFrom<&[&str]> for CertificateChain {
    type Error = Error;

    fn try_from(pems: &[&str]) -> ::core::result::Result<Self, Self::Error> {
        let certificates = pems
            .iter()
            .map(|pem| UnverifiedCertificate::try_from(*pem))
            .collect::<Vec<_>>()
            .into_iter()
            .collect::<Result<Vec<_>>>()?;

        Ok(Self { certificates })
    }
}

/// Convert a series DER-encoded certificates into a [`CertificateChain`].
///
/// The DERs must be in order from the trust anchor to the leaf certificate.
impl TryFrom<&[&[u8]]> for CertificateChain {
    type Error = Error;

    fn try_from(ders: &[&[u8]]) -> ::core::result::Result<Self, Self::Error> {
        let certificates = ders
            .iter()
            .map(|der| UnverifiedCertificate::try_from(*der))
            .collect::<Vec<_>>()
            .into_iter()
            .collect::<Result<Vec<_>>>()?;

        Ok(Self { certificates })
    }
}

fn verify_certificate_not_revoked(
    cert: &VerifiedCertificate,
    trust_anchor: &VerifiedCertificate,
    crls: &[UnverifiedCrl],
    unix_time: Duration,
) -> Result<()> {
    for crl in crls {
        if crl.issuer() == trust_anchor.subject_name() {
            let verified_crl = crl.verify(trust_anchor.public_key(), unix_time)?;
            if verified_crl.is_cert_revoked(cert.serial_number()) {
                return Err(Error::CertificateRevoked);
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod test {
    use super::*;

    use x509_cert::crl::CertificateList;
    use x509_cert::der::{Decode, DecodePem};
    use x509_cert::Certificate as X509Certificate;
    use yare::parameterized;

    const LEAF_CERT: &str = include_str!("../../data/tests/leaf_cert.pem");
    const PROCESSOR_CA: &str = include_str!("../../data/tests/processor_ca.pem");
    const ROOT_CA: &str = include_str!("../../data/tests/root_ca.pem");
    const ROOT_CRL: &str = include_str!("../../data/tests/root_crl.pem");
    const PROCESSOR_CRL: &str = include_str!("../../data/tests/processor_crl.pem");

    fn key_and_start_time(cert: &str) -> (PublicKey, Duration) {
        let cert = X509Certificate::from_pem(cert).expect("Failed decoding PEM");

        // The leaf certificate should have the narrowest time range.
        let unix_time = cert.tbs_certificate.validity.not_before.to_unix_duration();
        let key = PublicKey::try_from(&cert.tbs_certificate.subject_public_key_info)
            .expect("failed decoding key");

        (key, unix_time)
    }

    #[parameterized(
        full_chain = { &[ROOT_CA, PROCESSOR_CA, LEAF_CERT] },
        to_intermediate = { &[ROOT_CA, PROCESSOR_CA] },
        only_root = { &[ROOT_CA] },
    )]
    fn signing_key_from_certificate_chain(pem_chain: &[&str]) {
        let chain = CertificateChain::try_from(pem_chain).expect("Failed decoding pems");

        let end = pem_chain
            .last()
            .expect("Should be at least one certificate");
        let (expected_key, unix_time) = key_and_start_time(end);

        let root = VerifiedCertificate::try_from_self_signed_pem(ROOT_CA, unix_time)
            .expect("Failed verifying root");

        let signing_key = chain
            .signing_key(&root, unix_time, &[])
            .expect("Failed getting signing key");
        assert_eq!(signing_key, expected_key);
    }

    #[test]
    fn signing_key_fails_when_outside_valid_time() {
        let chain = CertificateChain::try_from([ROOT_CA, PROCESSOR_CA, LEAF_CERT].as_slice())
            .expect("Failed decoding pems");

        let (_, mut unix_time) = key_and_start_time(LEAF_CERT);

        unix_time -= Duration::from_nanos(1);

        let root = VerifiedCertificate::try_from_self_signed_pem(ROOT_CA, unix_time)
            .expect("Failed verifying root");

        assert_eq!(
            chain.signing_key(&root, unix_time, &[]),
            Err(Error::CertificateNotYetValid)
        );
    }

    #[test]
    fn cert_chain_out_of_order_fails() {
        let chain = CertificateChain::try_from([ROOT_CA, LEAF_CERT, PROCESSOR_CA].as_slice())
            .expect("Failed decoding pems");
        let (_, unix_time) = key_and_start_time(LEAF_CERT);
        let root = VerifiedCertificate::try_from_self_signed_pem(ROOT_CA, unix_time)
            .expect("Failed verifying root");

        assert_eq!(
            chain.signing_key(&root, unix_time, &[]),
            Err(Error::SignatureVerification)
        );
    }

    #[test]
    fn cert_chain_missing_intermediate_ca_fails() {
        let chain = CertificateChain::try_from([ROOT_CA, LEAF_CERT].as_slice())
            .expect("Failed decoding pems");
        let (_, unix_time) = key_and_start_time(LEAF_CERT);
        let root = VerifiedCertificate::try_from_self_signed_pem(ROOT_CA, unix_time)
            .expect("Failed verifying root");

        assert_eq!(
            chain.signing_key(&root, unix_time, &[]),
            Err(Error::SignatureVerification)
        );
    }

    #[test]
    fn certificate_chain_with_crls() {
        let chain = CertificateChain::try_from([ROOT_CA, PROCESSOR_CA, LEAF_CERT].as_slice())
            .expect("Failed decoding pems");

        let crls = [ROOT_CRL, PROCESSOR_CRL]
            .iter()
            .map(|crl| UnverifiedCrl::try_from(*crl).expect("Failed decoding CRL"))
            .collect::<Vec<_>>();

        let (expected_key, _) = key_and_start_time(LEAF_CERT);

        // CRLs are often only for a month, while certs are for years, so use CRL's time
        let (_, der_bytes) =
            pem_rfc7468::decode_vec(PROCESSOR_CRL.as_bytes()).expect("Failed decoding PEM");
        let crl = CertificateList::from_der(der_bytes.as_slice()).expect("Failed decoding DER");
        let mut unix_time = crl
            .tbs_cert_list
            .next_update
            .expect("CRL should have next update")
            .to_unix_duration();
        unix_time -= Duration::from_nanos(1);

        let root = VerifiedCertificate::try_from_self_signed_pem(ROOT_CA, unix_time)
            .expect("Failed verifying root");

        let signing_key = chain
            .signing_key(&root, unix_time, crls.as_slice())
            .expect("Failed getting signing key");
        assert_eq!(signing_key, expected_key);
    }

    #[test]
    fn crl_after_valid_date_fails() {
        let chain = CertificateChain::try_from([ROOT_CA, PROCESSOR_CA, LEAF_CERT].as_slice())
            .expect("Failed decoding pems");

        let crls = [ROOT_CRL, PROCESSOR_CRL]
            .iter()
            .map(|crl| UnverifiedCrl::try_from(*crl).expect("Failed decoding CRL"))
            .collect::<Vec<_>>();

        let (_, der_bytes) =
            pem_rfc7468::decode_vec(PROCESSOR_CRL.as_bytes()).expect("Failed decoding PEM");
        let crl = CertificateList::from_der(der_bytes.as_slice()).expect("Failed decoding DER");
        let unix_time = crl
            .tbs_cert_list
            .next_update
            .expect("CRL should have next update")
            .to_unix_duration();

        let root = VerifiedCertificate::try_from_self_signed_pem(ROOT_CA, unix_time)
            .expect("Failed verifying root");

        assert_eq!(
            chain.signing_key(&root, unix_time, crls.as_slice()),
            Err(Error::CrlExpired)
        );
    }
}

#[cfg(test)]
mod pkits {
    use super::*;

    use x509_cert::crl::CertificateList;
    use x509_cert::der::Decode;
    use x509_cert::Certificate as X509Certificate;

    const TRUST_ANCHOR_ROOT_CERTIFICATE: &[u8] =
        include_bytes!("../../data/tests/pkits/certs/TrustAnchorRootCertificate.crt");
    const GOOD_CA_CERT: &[u8] = include_bytes!("../../data/tests/pkits/certs/GoodCACert.crt");
    const VALID_CERTIFICATE_PATH_TEST_1EE: &[u8] =
        include_bytes!("../../data/tests/pkits/certs/ValidCertificatePathTest1EE.crt");
    const TRUST_ANCHOR_ROOT_CRL: &[u8] =
        include_bytes!("../../data/tests/pkits/crls/TrustAnchorRootCRL.crl");
    const GOOD_CA_CRL: &[u8] = include_bytes!("../../data/tests/pkits/crls/GoodCACRL.crl");
    const BAD_SIGNED_CA_CERT: &[u8] =
        include_bytes!("../../data/tests/pkits/certs/BadSignedCACert.crt");
    const BAD_SIGNED_CA_CRL: &[u8] =
        include_bytes!("../../data/tests/pkits/crls/BadSignedCACRL.crl");
    const INVALID_CA_SIGNATURE_TEST_2EE: &[u8] =
        include_bytes!("../../data/tests/pkits/certs/InvalidCASignatureTest2EE.crt");
    const INVALID_EE_SIGNATURE_TEST_3EE: &[u8] =
        include_bytes!("../../data/tests/pkits/certs/InvalidEESignatureTest3EE.crt");

    fn chain_and_leaf_key(certs: &[&[u8]]) -> (CertificateChain, PublicKey) {
        let chain = CertificateChain::try_from(certs).expect("Failed decoding certs");

        let leaf_der = certs.last().expect("Should be at least one cert");
        let leaf_cert = X509Certificate::from_der(leaf_der).expect("Falied decoding DER");
        let key = PublicKey::try_from(&leaf_cert.tbs_certificate.subject_public_key_info)
            .expect("Failed decoding key");

        (chain, key)
    }

    fn crls_and_time(der_crls: &[&[u8]]) -> (Vec<UnverifiedCrl>, Duration) {
        let crls = der_crls
            .iter()
            .map(|crl| UnverifiedCrl::try_from(*crl).expect("Failed decoding CRL"))
            .collect::<Vec<_>>();

        let last_der = der_crls.last().expect("Should be at least one CRL");
        let crl = CertificateList::from_der(last_der).expect("Falied decoding DER");
        let unix_time = crl.tbs_cert_list.this_update.to_unix_duration();
        (crls, unix_time)
    }

    #[test]
    fn valid_signatures_test_4_1_1() {
        let (chain, expected_key) = chain_and_leaf_key(
            [
                TRUST_ANCHOR_ROOT_CERTIFICATE,
                GOOD_CA_CERT,
                VALID_CERTIFICATE_PATH_TEST_1EE,
            ]
            .as_slice(),
        );
        let (crls, unix_time) = crls_and_time([TRUST_ANCHOR_ROOT_CRL, GOOD_CA_CRL].as_slice());

        let root = chain.certificates[0]
            .verify_self_signed(unix_time)
            .expect("Failed verifying root");

        let signing_key = chain
            .signing_key(&root, unix_time, crls.as_slice())
            .expect("Failed getting signing key");

        assert_eq!(signing_key, expected_key);
    }

    #[test]
    fn invalid_ca_signature_test_4_1_2() {
        let certs = [
            TRUST_ANCHOR_ROOT_CERTIFICATE,
            BAD_SIGNED_CA_CERT,
            INVALID_CA_SIGNATURE_TEST_2EE,
        ];

        // Building the chain parses the signatures of each certificate. The
        // invalid signature causes a parsing error.
        assert_eq!(
            CertificateChain::try_from(certs.as_slice()),
            Err(Error::SignatureDecoding)
        );
    }

    #[test]
    fn invalid_ee_signature_test_4_1_3() {
        let (chain, _) = chain_and_leaf_key(
            [
                TRUST_ANCHOR_ROOT_CERTIFICATE,
                GOOD_CA_CERT,
                INVALID_EE_SIGNATURE_TEST_3EE,
            ]
            .as_slice(),
        );
        let (crls, unix_time) = crls_and_time([TRUST_ANCHOR_ROOT_CRL, GOOD_CA_CRL].as_slice());

        let root = chain.certificates[0]
            .verify_self_signed(unix_time)
            .expect("Failed verifying root");

        assert_eq!(
            chain.signing_key(&root, unix_time, crls.as_slice()),
            Err(Error::SignatureVerification)
        );
    }

    // Tests 4.1.4 - 4.1.6 are not implemented because DSA has been deprecated, see
    // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5-draft.pdf#%5B%7B%22num%22%3A72%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C72%2C721%2Cnull%5D
}
