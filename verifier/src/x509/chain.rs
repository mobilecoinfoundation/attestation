// Copyright (c) 2023 The MobileCoin Foundation

//! Support for verifying certificate chains

extern crate alloc;

use super::certs::UnverifiedCertificate;
use super::{Error, Result};
use crate::x509::algorithm::PublicKey;
use crate::x509::certs::VerifiedCertificate;
use crate::x509::crl::UnverifiedCrl;
use crate::x509::name::DistinguishedName;
use alloc::vec::Vec;
use core::time::Duration;

/// An X509 certificate chain. This is a valid path from the trust root to the
/// leaf certificate.
#[derive(Debug, PartialEq)]
pub struct CertificateChain {
    certificates: Vec<UnverifiedCertificate>,
}

impl CertificateChain {
    /// Create a new certificate chain from a path from a trust root to the
    /// leaf certificate.
    ///
    /// A certificate chain without a valid path will result in errors for
    /// functions like [`CertificateChain::signing_key`].
    pub fn new(certificates: Vec<UnverifiedCertificate>) -> Self {
        Self { certificates }
    }

    /// Returning the signing key from the leaf certificate
    ///
    /// The chain will be verified against the `trust_anchor`, `unix_time`, and
    /// `crls`.
    ///
    /// # Arguments
    /// * `trust_anchor` - The trust anchor of the chain. This is often a
    ///   previously known certificate.
    /// * `unix_time` - The duration since
    ///   [`UNIX_EPOCH`](https://doc.rust-lang.org/std/time/constant.UNIX_EPOCH.html).
    ///   This is expected to be generated by the caller using:
    ///     ```ignore
    ///     SystemTime::now().duration_since(UNIX_EPOCH)
    ///     ```
    ///   or equivalent
    /// * `crls` - A list of certificate revocation lists that will be used to
    ///   reject revoked certificates.
    pub fn signing_key(
        &self,
        trust_anchor: &VerifiedCertificate,
        unix_time: Duration,
        crls: &[UnverifiedCrl],
    ) -> Result<PublicKey> {
        let mut signing_cert = trust_anchor.clone();
        for cert in &self.certificates {
            let key = signing_cert.public_key();
            let verified_cert = cert.verify(key, unix_time)?;
            verify_name_chain(&verified_cert, &signing_cert)?;
            verify_certificate_not_revoked(&verified_cert, &signing_cert, crls, unix_time)?;
            signing_cert = verified_cert;
        }
        Ok(signing_cert.public_key().clone())
    }
}

impl AsRef<[UnverifiedCertificate]> for CertificateChain {
    fn as_ref(&self) -> &[UnverifiedCertificate] {
        &self.certificates
    }
}

/// Convert a series PEM-encoded certificates into a [`CertificateChain`].
///
/// The PEMs must be in order from the trust anchor to the leaf certificate.
impl TryFrom<&[&str]> for CertificateChain {
    type Error = Error;

    fn try_from(pems: &[&str]) -> ::core::result::Result<Self, Self::Error> {
        let certificates = pems
            .iter()
            .map(|pem| UnverifiedCertificate::try_from(*pem))
            .collect::<Vec<_>>()
            .into_iter()
            .collect::<Result<Vec<_>>>()?;

        Ok(Self { certificates })
    }
}

/// Convert a series DER-encoded certificates into a [`CertificateChain`].
///
/// The DERs must be in order from the trust anchor to the leaf certificate.
impl TryFrom<&[&[u8]]> for CertificateChain {
    type Error = Error;

    fn try_from(ders: &[&[u8]]) -> ::core::result::Result<Self, Self::Error> {
        let certificates = ders
            .iter()
            .map(|der| UnverifiedCertificate::try_from(*der))
            .collect::<Vec<_>>()
            .into_iter()
            .collect::<Result<Vec<_>>>()?;

        Ok(Self { certificates })
    }
}

/// Ensures the issuer matches the subject as specified in
/// https://datatracker.ietf.org/doc/html/rfc5280#section-7.1
fn verify_name_chain(cert: &VerifiedCertificate, ca: &VerifiedCertificate) -> Result<()> {
    let issuer = DistinguishedName::from(cert.issuer());
    let subject = DistinguishedName::from(ca.subject_name());

    if issuer == subject {
        Ok(())
    } else {
        Err(Error::NameChaining)
    }
}

fn verify_certificate_not_revoked(
    cert: &VerifiedCertificate,
    ca: &VerifiedCertificate,
    crls: &[UnverifiedCrl],
    unix_time: Duration,
) -> Result<()> {
    for crl in crls {
        if crl.issuer() == ca.subject_name() {
            let verified_crl = crl.verify(ca.public_key(), unix_time)?;
            if verified_crl.is_cert_revoked(cert.serial_number()) {
                return Err(Error::CertificateRevoked);
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod test {
    use super::*;

    use x509_cert::crl::CertificateList;
    use x509_cert::der::{Decode, DecodePem};
    use x509_cert::Certificate as X509Certificate;
    use yare::parameterized;

    const LEAF_CERT: &str = include_str!("../../data/tests/leaf_cert.pem");
    const PROCESSOR_CA: &str = include_str!("../../data/tests/processor_ca.pem");
    const ROOT_CA: &str = include_str!("../../data/tests/root_ca.pem");
    const ROOT_CRL: &str = include_str!("../../data/tests/root_crl.pem");
    const PROCESSOR_CRL: &str = include_str!("../../data/tests/processor_crl.pem");

    fn key_and_start_time(cert: &str) -> (PublicKey, Duration) {
        let cert = X509Certificate::from_pem(cert).expect("Failed decoding PEM");

        // The leaf certificate should have the narrowest time range.
        let unix_time = cert.tbs_certificate.validity.not_before.to_unix_duration();
        let key = PublicKey::try_from(&cert.tbs_certificate.subject_public_key_info)
            .expect("failed decoding key");

        (key, unix_time)
    }

    #[parameterized(
        full_chain = { &[ROOT_CA, PROCESSOR_CA, LEAF_CERT] },
        to_intermediate = { &[ROOT_CA, PROCESSOR_CA] },
        only_root = { &[ROOT_CA] },
    )]
    fn signing_key_from_certificate_chain(pem_chain: &[&str]) {
        let chain = CertificateChain::try_from(pem_chain).expect("Failed decoding pems");

        let end = pem_chain
            .last()
            .expect("Should be at least one certificate");
        let (expected_key, unix_time) = key_and_start_time(end);

        let root = VerifiedCertificate::try_from_self_signed_pem(ROOT_CA, unix_time)
            .expect("Failed verifying root");

        let signing_key = chain
            .signing_key(&root, unix_time, &[])
            .expect("Failed getting signing key");
        assert_eq!(signing_key, expected_key);
    }

    #[test]
    fn signing_key_fails_when_outside_valid_time() {
        let chain = CertificateChain::try_from([ROOT_CA, PROCESSOR_CA, LEAF_CERT].as_slice())
            .expect("Failed decoding pems");

        let (_, mut unix_time) = key_and_start_time(LEAF_CERT);

        unix_time -= Duration::from_nanos(1);

        let root = VerifiedCertificate::try_from_self_signed_pem(ROOT_CA, unix_time)
            .expect("Failed verifying root");

        assert_eq!(
            chain.signing_key(&root, unix_time, &[]),
            Err(Error::CertificateNotYetValid)
        );
    }

    #[test]
    fn cert_chain_out_of_order_fails() {
        let chain = CertificateChain::try_from([ROOT_CA, LEAF_CERT, PROCESSOR_CA].as_slice())
            .expect("Failed decoding pems");
        let (_, unix_time) = key_and_start_time(LEAF_CERT);
        let root = VerifiedCertificate::try_from_self_signed_pem(ROOT_CA, unix_time)
            .expect("Failed verifying root");

        assert_eq!(
            chain.signing_key(&root, unix_time, &[]),
            Err(Error::SignatureVerification)
        );
    }

    #[test]
    fn cert_chain_missing_intermediate_ca_fails() {
        let chain = CertificateChain::try_from([ROOT_CA, LEAF_CERT].as_slice())
            .expect("Failed decoding pems");
        let (_, unix_time) = key_and_start_time(LEAF_CERT);
        let root = VerifiedCertificate::try_from_self_signed_pem(ROOT_CA, unix_time)
            .expect("Failed verifying root");

        assert_eq!(
            chain.signing_key(&root, unix_time, &[]),
            Err(Error::SignatureVerification)
        );
    }

    #[test]
    fn certificate_chain_with_crls() {
        let chain = CertificateChain::try_from([ROOT_CA, PROCESSOR_CA, LEAF_CERT].as_slice())
            .expect("Failed decoding pems");

        let crls = [ROOT_CRL, PROCESSOR_CRL]
            .iter()
            .map(|crl| UnverifiedCrl::try_from(*crl).expect("Failed decoding CRL"))
            .collect::<Vec<_>>();

        let (expected_key, _) = key_and_start_time(LEAF_CERT);

        // CRLs are often only for a month, while certs are for years, so use CRL's time
        let (_, der_bytes) =
            pem_rfc7468::decode_vec(PROCESSOR_CRL.as_bytes()).expect("Failed decoding PEM");
        let crl = CertificateList::from_der(der_bytes.as_slice()).expect("Failed decoding DER");
        let mut unix_time = crl
            .tbs_cert_list
            .next_update
            .expect("CRL should have next update")
            .to_unix_duration();
        unix_time -= Duration::from_nanos(1);

        let root = VerifiedCertificate::try_from_self_signed_pem(ROOT_CA, unix_time)
            .expect("Failed verifying root");

        let signing_key = chain
            .signing_key(&root, unix_time, crls.as_slice())
            .expect("Failed getting signing key");
        assert_eq!(signing_key, expected_key);
    }

    #[test]
    fn crl_after_valid_date_fails() {
        let chain = CertificateChain::try_from([ROOT_CA, PROCESSOR_CA, LEAF_CERT].as_slice())
            .expect("Failed decoding pems");

        let crls = [ROOT_CRL, PROCESSOR_CRL]
            .iter()
            .map(|crl| UnverifiedCrl::try_from(*crl).expect("Failed decoding CRL"))
            .collect::<Vec<_>>();

        let (_, der_bytes) =
            pem_rfc7468::decode_vec(PROCESSOR_CRL.as_bytes()).expect("Failed decoding PEM");
        let crl = CertificateList::from_der(der_bytes.as_slice()).expect("Failed decoding DER");
        let unix_time = crl
            .tbs_cert_list
            .next_update
            .expect("CRL should have next update")
            .to_unix_duration();

        let root = VerifiedCertificate::try_from_self_signed_pem(ROOT_CA, unix_time)
            .expect("Failed verifying root");

        assert_eq!(
            chain.signing_key(&root, unix_time, crls.as_slice()),
            Err(Error::CrlExpired)
        );
    }
}
