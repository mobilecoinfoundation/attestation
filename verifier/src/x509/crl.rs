// Copyright (c) 2023 The MobileCoin Foundation

//! Certificate Revocation List (CRL) support.

extern crate alloc;

use super::{Error, Result};
use alloc::borrow::ToOwned;
use alloc::vec::Vec;
use core::time::Duration;
use p256::ecdsa::signature::Verifier;
use p256::ecdsa::{Signature, VerifyingKey};
use x509_cert::crl::CertificateList;
use x509_cert::der::{Decode, Encode};
use x509_cert::time::Time;

/// A certificate revocation list (CRL).
#[derive(Debug, PartialEq, Eq)]
pub struct UnverifiedCrl {
    // In order to verify the signature, we need to access the original DER
    // bytes
    der_bytes: Vec<u8>,
    crl: CertificateList,
    // The signature is persisted here since they are fallible
    // operations and it's more ergonomic to fail fast than fail later for a
    // bad key or signature
    signature: Signature,
    // Per https://www.rfc-editor.org/rfc/rfc5280#section-5.1.2.5 the next
    // update MUST be included. We treat the CRL as invalid if it lacks the
    // next update time. Also note that next update is when the next CRL should
    // be issued so this value is treated as exclusive
    next_update: Time,
}

/// A certificate whose signature has been verified.
#[derive(Debug, PartialEq, Eq)]
pub struct VerifiedCrl {
    _crl: CertificateList,
}

impl UnverifiedCrl {
    /// Verify the CRL signature is valid.
    ///
    /// # Arguments
    /// - `key` - The public key to verify the CRL signature with.
    /// - `unix_time` - The duration since
    ///   [`UNIX_EPOCH`](https://doc.rust-lang.org/std/time/constant.UNIX_EPOCH.html).
    ///   This is expected to be generated by the caller using:
    ///     ```ignore
    ///     SystemTime::now().duration_since(UNIX_EPOCH)
    ///     ```
    ///   or equivalent
    pub fn verify(self, key: &VerifyingKey, unix_time: Duration) -> Result<VerifiedCrl> {
        self.verify_signature(key)?;
        self.verify_time(unix_time)?;

        Ok(VerifiedCrl { _crl: self.crl })
    }

    fn verify_signature(&self, key: &VerifyingKey) -> Result<()> {
        let tbs_size = u32::from(self.crl.tbs_cert_list.encoded_len()?) as usize;
        let signature_size = u32::from(self.crl.signature.encoded_len()?) as usize;
        let algorithm_size = u32::from(self.crl.signature_algorithm.encoded_len()?) as usize;
        let overall_size = u32::from(self.crl.encoded_len()?) as usize;

        let tbs_offset = overall_size - (tbs_size + signature_size + algorithm_size);
        let tbs_contents = &self.der_bytes[tbs_offset..tbs_size + tbs_offset];
        key.verify(tbs_contents, &self.signature)
            .map_err(|_| Error::SignatureVerification)?;
        Ok(())
    }

    fn verify_time(&self, unix_time: Duration) -> Result<()> {
        let this_update = self.crl.tbs_cert_list.this_update.to_unix_duration();
        let next_update = self.next_update.to_unix_duration();

        if unix_time < this_update {
            Err(Error::CrlNotYetValid)
        } else if unix_time >= next_update {
            Err(Error::CrlExpired)
        } else {
            Ok(())
        }
    }
}

/// Convert a PEM-encoded CRL into an [`UnverifiedCrl`].
impl TryFrom<&str> for UnverifiedCrl {
    type Error = Error;

    fn try_from(pem: &str) -> ::core::result::Result<Self, Self::Error> {
        let (_, der_bytes) = pem_rfc7468::decode_vec(pem.as_bytes())?;
        Self::try_from(&der_bytes[..])
    }
}

/// Convert a DER-encoded CRL into an [`UnverifiedCrl`].
impl TryFrom<&[u8]> for UnverifiedCrl {
    type Error = Error;

    fn try_from(der_bytes: &[u8]) -> ::core::result::Result<Self, Self::Error> {
        let crl = CertificateList::from_der(der_bytes)?;
        let signature_bytes = crl.signature.as_bytes().ok_or(Error::SignatureDecoding)?;
        let signature =
            Signature::from_der(signature_bytes).map_err(|_| Error::SignatureDecoding)?;

        let next_update = crl
            .tbs_cert_list
            .next_update
            .ok_or(Error::CrlMissingNextUpdate)?;

        Ok(UnverifiedCrl {
            der_bytes: der_bytes.to_owned(),
            crl,
            signature,
            next_update,
        })
    }
}

#[cfg(test)]
mod test {
    use super::super::certs::UnverifiedCertificate;
    use super::*;
    use alloc::string::ToString;
    use x509_cert::der::Decode;
    use x509_cert::Certificate as X509Certificate;

    use yare::parameterized;

    const ROOT_CRL: &str = include_str!("../../data/tests/root_crl.pem");
    const ROOT_CA: &str = include_str!("../../data/tests/root_ca.pem");
    const PROCESSOR_CRL: &str = include_str!("../../data/tests/processor_crl.pem");
    const PROCESSOR_CA: &str = include_str!("../../data/tests/processor_ca.pem");

    #[parameterized(
        root = { ROOT_CRL },
        processor = { PROCESSOR_CRL },
    )]
    fn try_from_pem(pem: &str) {
        assert!(UnverifiedCrl::try_from(pem).is_ok());
    }

    #[test]
    fn try_from_bad_pem_errors() {
        let pem = ROOT_CRL.to_string();
        let bad_pem = pem.replace("-----END X509 CRL-----", "");

        assert!(matches!(
            UnverifiedCrl::try_from(bad_pem.as_str()),
            Err(Error::PemDecoding(_))
        ));
    }

    #[parameterized(
    root = { ROOT_CRL },
    processor = { PROCESSOR_CRL },
    )]
    fn try_from_der(pem: &str) {
        let (_, der_bytes) =
            pem_rfc7468::decode_vec(pem.as_bytes()).expect("Failed to decode DER from PEM");
        assert!(UnverifiedCrl::try_from(der_bytes.as_slice()).is_ok());
    }

    #[test]
    fn crl_decoding_error_with_invalid_der() {
        let (_, der_bytes) =
            pem_rfc7468::decode_vec(ROOT_CRL.as_bytes()).expect("Failed to decode DER from PEM");
        assert!(matches!(
            UnverifiedCrl::try_from(&der_bytes.as_slice()[1..]),
            Err(Error::DerDecoding(_))
        ));
    }

    #[test]
    fn signature_decoding_error() {
        let (_, mut der_bytes) =
            pem_rfc7468::decode_vec(ROOT_CRL.as_bytes()).expect("Failed to decode DER from PEM");

        // The signature is at the end of the CRL.
        // If either of the points are 0 it will fail to decode so we force the
        // last point to 0
        let last_point = der_bytes.len() - 32;
        der_bytes[last_point..].copy_from_slice(&[0; 32]);

        assert_eq!(
            UnverifiedCrl::try_from(der_bytes.as_slice()),
            Err(Error::SignatureDecoding)
        );
    }

    #[test]
    fn next_update_time_missing_error() {
        let (_, der_bytes) =
            pem_rfc7468::decode_vec(ROOT_CRL.as_bytes()).expect("Failed to decode DER from PEM");

        let mut crl =
            CertificateList::from_der(der_bytes.as_slice()).expect("Failed to decode CRL");
        crl.tbs_cert_list.next_update = None;

        let der_bytes = crl.to_der().expect("Failed to encode CRL");

        assert_eq!(
            UnverifiedCrl::try_from(der_bytes.as_slice()),
            Err(Error::CrlMissingNextUpdate)
        );
    }

    #[parameterized{
        root = { ROOT_CA, ROOT_CRL, },
        processor = { PROCESSOR_CA, PROCESSOR_CRL, },
    }]
    fn verify_crl(ca_pem: &str, crl_pem: &str) {
        let crl = UnverifiedCrl::try_from(crl_pem).expect("Failed to decode CRL");
        let unix_time = crl.crl.tbs_cert_list.this_update.to_unix_duration();

        let (_, der_bytes) =
            pem_rfc7468::decode_vec(ca_pem.as_bytes()).expect("Failed decoding PEM");
        let x509_cert =
            X509Certificate::from_der(der_bytes.as_slice()).expect("Falied decoding DER");

        let signing_key = VerifyingKey::from_sec1_bytes(
            x509_cert
                .tbs_certificate
                .subject_public_key_info
                .subject_public_key
                .as_bytes()
                .expect("Failed decoding key"),
        )
        .expect("Failed decoding key");

        assert_eq!(crl.verify(&signing_key, unix_time).is_ok(), true);
    }

    #[test]
    fn verify_fails_with_wrong_key() {
        let crl = UnverifiedCrl::try_from(PROCESSOR_CRL).expect("Failed to decode CRL");
        let unix_time = crl.crl.tbs_cert_list.this_update.to_unix_duration();

        let unverified_ca =
            UnverifiedCertificate::try_from(ROOT_CA).expect("Failed to decode certificate");
        let ca = unverified_ca
            .verify_self_signed(unix_time)
            .expect("Failed to verify certificate");

        assert_eq!(
            crl.verify(&ca.public_key(), unix_time),
            Err(Error::SignatureVerification)
        );
    }

    #[test]
    fn clr_before_this_update_fails() {
        let crl = UnverifiedCrl::try_from(ROOT_CRL).expect("Failed to decode CRL");
        let mut unix_time = crl.crl.tbs_cert_list.this_update.to_unix_duration();

        let unverified_ca =
            UnverifiedCertificate::try_from(ROOT_CA).expect("Failed to decode certificate");
        let ca = unverified_ca
            .verify_self_signed(unix_time)
            .expect("Failed to verify certificate");

        unix_time -= Duration::from_nanos(1);

        assert_eq!(
            crl.verify(&ca.public_key(), unix_time),
            Err(Error::CrlNotYetValid)
        );
    }

    #[test]
    fn clr_before_next_update_succeeds() {
        let crl = UnverifiedCrl::try_from(ROOT_CRL).expect("Failed to decode CRL");
        let mut unix_time = crl
            .crl
            .tbs_cert_list
            .next_update
            .expect("Expected a valid update time")
            .to_unix_duration();

        let unverified_ca =
            UnverifiedCertificate::try_from(ROOT_CA).expect("Failed to decode certificate");
        let ca = unverified_ca
            .verify_self_signed(unix_time)
            .expect("Failed to verify certificate");

        unix_time -= Duration::from_nanos(1);

        assert_eq!(crl.verify(&ca.public_key(), unix_time).is_ok(), true);
    }

    #[test]
    fn clr_at_next_update_fails() {
        let crl = UnverifiedCrl::try_from(ROOT_CRL).expect("Failed to decode CRL");
        let unix_time = crl
            .crl
            .tbs_cert_list
            .next_update
            .expect("Expected a valid update time")
            .to_unix_duration();

        let unverified_ca =
            UnverifiedCertificate::try_from(ROOT_CA).expect("Failed to decode certificate");
        let ca = unverified_ca
            .verify_self_signed(unix_time)
            .expect("Failed to verify certificate");

        assert_eq!(
            crl.verify(&ca.public_key(), unix_time),
            Err(Error::CrlExpired)
        );
    }
}
